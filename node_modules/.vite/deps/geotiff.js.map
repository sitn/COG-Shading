{
  "version": 3,
  "sources": ["../../xml-utils/get-attribute.js", "../../xml-utils/index-of-match.js", "../../xml-utils/index-of-match-end.js", "../../xml-utils/count-substring.js", "../../xml-utils/find-tag-by-name.js", "../../xml-utils/find-tags-by-name.js", "browser-external:http", "browser-external:https", "browser-external:url", "browser-external:fs", "../../@petamoriken/float16/src/_util/messages.mjs", "../../@petamoriken/float16/src/_util/primordials.mjs", "../../@petamoriken/float16/src/_util/arrayIterator.mjs", "../../@petamoriken/float16/src/_util/is.mjs", "../../@petamoriken/float16/src/_util/brand.mjs", "../../@petamoriken/float16/src/_util/converter.mjs", "../../@petamoriken/float16/src/_util/spec.mjs", "../../@petamoriken/float16/src/Float16Array.mjs", "../../@petamoriken/float16/src/DataView.mjs", "../../geotiff/dist-module/geotiffimage.js", "../../geotiff/dist-module/rgb.js", "../../geotiff/dist-module/compression/index.js", "../../geotiff/dist-module/resample.js", "../../geotiff/dist-module/dataview64.js", "../../geotiff/dist-module/dataslice.js", "../../geotiff/dist-module/pool.js", "../../geotiff/dist-module/source/httputils.js", "../../geotiff/dist-module/source/basesource.js", "../../quick-lru/index.js", "../../geotiff/dist-module/utils.js", "../../geotiff/dist-module/source/blockedsource.js", "../../geotiff/dist-module/source/client/base.js", "../../geotiff/dist-module/source/client/fetch.js", "../../geotiff/dist-module/source/client/xhr.js", "../../geotiff/dist-module/source/client/http.js", "../../geotiff/dist-module/source/remote.js", "../../geotiff/dist-module/source/arraybuffer.js", "../../geotiff/dist-module/source/filereader.js", "../../geotiff/dist-module/source/file.js", "../../geotiff/dist-module/geotiffwriter.js", "../../geotiff/dist-module/logging.js", "../../geotiff/dist-module/geotiff.js"],
  "sourcesContent": ["function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports.default = getAttribute;\n", "function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports.default = indexOfMatch;\n", "function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports.default = indexOfMatchEnd;\n", "function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports.default = countSubstring;\n", "const indexOfMatch = require(\"./index-of-match.js\");\nconst indexOfMatchEnd = require(\"./index-of-match-end.js\");\nconst countSubstring = require(\"./count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports.default = findTagByName;\n", "const findTagByName = require(\"./find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports.default = findTagsByName;\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"http\" has been externalized for browser compatibility. Cannot access \"http.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"https\" has been externalized for browser compatibility. Cannot access \"https.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"url\" has been externalized for browser compatibility. Cannot access \"url.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"fs\" has been externalized for browser compatibility. Cannot access \"fs.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "export const THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\nexport const THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\nexport const THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY =\n  \"This constructor is not a subclass of Float16Array\";\nexport const THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT =\n  \"The constructor property value is not an object\";\nexport const SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT =\n  \"Species constructor didn't return TypedArray object\";\nexport const DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH =\n  \"Derived constructor created TypedArray object which was too small length\";\nexport const ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER =\n  \"Attempting to access detached ArrayBuffer\";\nexport const CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT =\n  \"Cannot convert undefined or null to object\";\nexport const CANNOT_MIX_BIGINT_AND_OTHER_TYPES =\n  \"Cannot mix BigInt and other types, use explicit conversions\";\nexport const ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\nexport const REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE =\n  \"Reduce of empty array with no initial value\";\nexport const THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED =\n  \"The comparison function must be either a function or undefined\";\nexport const OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\n", "/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\nimport { CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT } from \"./messages.mjs\";\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nexport const {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nexport const NativeProxy = Proxy;\n\n// Number\nexport const {\n  EPSILON,\n  MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = Number;\n\n// Symbol\nexport const {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nexport const NativeObject = Object;\nexport const {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nexport const ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nexport const ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nexport const ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nexport const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nexport const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nexport const ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nexport const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nexport const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nexport const {\n  abs: MathAbs,\n  trunc: MathTrunc,\n} = Math;\n\n// ArrayBuffer\nexport const NativeArrayBuffer = ArrayBuffer;\nexport const ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nexport const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nexport const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nexport const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nexport const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nexport const TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nexport const TypedArrayPrototype = TypedArray.prototype;\nexport const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nexport const TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nexport const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nexport const TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nexport const TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nexport const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nexport const TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nexport const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint8Array\nexport const NativeUint8Array = Uint8Array;\n\n// Uint16Array\nexport const NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nexport const Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nexport const NativeUint32Array = Uint32Array;\n\n// Float32Array\nexport const NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nexport const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nexport const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nexport const GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nexport const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nexport const DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nexport const DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nexport const NativeTypeError = TypeError;\nexport const NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nexport const NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nexport const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nexport const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nexport const NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nexport const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nexport const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nexport const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n", "import {\n  ArrayIteratorPrototype,\n  ArrayIteratorPrototypeNext,\n  ArrayPrototypeSymbolIterator,\n  GeneratorPrototypeNext,\n  IteratorPrototype,\n  NativeArrayPrototypeSymbolIterator,\n  NativeWeakMap,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys,\n  SymbolIterator,\n  WeakMapPrototypeGet,\n  WeakMapPrototypeSet,\n} from \"./primordials.mjs\";\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new NativeWeakMap();\n\nconst SafeIteratorPrototype = ObjectCreate(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);\n      return ArrayIteratorPrototypeNext(arrayIterator);\n    },\n  },\n\n  [SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nexport function safeIfNeeded(array) {\n  if (\n    array[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n    ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n  ) {\n    return array;\n  }\n\n  const safe = ObjectCreate(SafeIteratorPrototype);\n  WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = WeakMapPrototypeGet(generators, this);\n      return GeneratorPrototypeNext(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nexport function wrap(generator) {\n  const dummy = ObjectCreate(DummyArrayIteratorPrototype);\n  WeakMapPrototypeSet(generators, dummy, generator);\n  return dummy;\n}\n", "import {\n  ArrayBufferPrototypeGetByteLength,\n  ArrayIsArray,\n  ArrayIteratorPrototype,\n  ArrayIteratorPrototypeNext,\n  MathTrunc,\n  NativeArrayPrototypeSymbolIterator,\n  NativeSharedArrayBuffer,\n  NativeTypedArrayPrototypeSymbolIterator,\n  NumberIsFinite,\n  SharedArrayBufferPrototypeGetByteLength,\n  SymbolIterator,\n  TypedArrayPrototypeGetSymbolToStringTag,\n} from \"./primordials.mjs\";\n\n/**\n * @param {unknown} value\n * @returns {value is {}}\n */\nexport function isObject(value) {\n  return (\n    (value !== null && typeof value === \"object\") ||\n    typeof value === \"function\"\n  );\n}\n\n/**\n * @param {unknown} value\n * @returns {value is {}}\n */\nexport function isObjectLike(value) {\n  return value !== null && typeof value === \"object\";\n}\n\n// Inspired by util.types implementation of Node.js\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n\n/**\n * @param {unknown} value\n * @returns {value is TypedArray}\n */\nexport function isNativeTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n}\n\n/**\n * @param {unknown} value\n * @returns {value is BigInt64Array|BigUint64Array}\n */\nexport function isNativeBigIntTypedArray(value) {\n  const typedArrayName = TypedArrayPrototypeGetSymbolToStringTag(value);\n  return (\n    typedArrayName === \"BigInt64Array\" ||\n    typedArrayName === \"BigUint64Array\"\n  );\n}\n\n/**\n * @param {unknown} value\n * @returns {value is ArrayBuffer}\n */\nfunction isArrayBuffer(value) {\n  try {\n    // ArrayBuffers are never arrays\n    if (ArrayIsArray(value)) {\n      return false;\n    }\n    ArrayBufferPrototypeGetByteLength(/** @type {any} */ (value));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {value is SharedArrayBuffer}\n */\nexport function isSharedArrayBuffer(value) {\n  if (NativeSharedArrayBuffer === null) {\n    return false;\n  }\n\n  try {\n    SharedArrayBufferPrototypeGetByteLength(/** @type {any} */ (value));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {value is ArrayBuffer|SharedArrayBuffer}\n */\nexport function isAnyArrayBuffer(value) {\n  return isArrayBuffer(value) || isSharedArrayBuffer(value);\n}\n\n/**\n * @param {unknown} value\n * @returns {value is unknown[]}\n */\nexport function isOrdinaryArray(value) {\n  if (!ArrayIsArray(value)) {\n    return false;\n  }\n\n  // Verify that there are no changes in ArrayIterator\n  return (\n    value[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n    ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n  );\n}\n\n/**\n * @param {unknown} value\n * @returns {value is TypedArray}\n */\nexport function isOrdinaryNativeTypedArray(value) {\n  if (!isNativeTypedArray(value)) {\n    return false;\n  }\n\n  // Verify that there are no changes in ArrayIterator\n  return (\n    value[SymbolIterator] === NativeTypedArrayPrototypeSymbolIterator &&\n    ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n  );\n}\n\n/**\n * @param {unknown} value\n * @returns {value is string}\n */\nexport function isCanonicalIntegerIndexString(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n\n  const number = +value;\n  if (value !== number + \"\") {\n    return false;\n  }\n\n  if (!NumberIsFinite(number)) {\n    return false;\n  }\n\n  return number === MathTrunc(number);\n}\n", "import { isObject, isObjectLike } from \"./is.mjs\";\nimport { THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT } from \"./messages.mjs\";\nimport { NativeTypeError, ReflectGetPrototypeOf, ReflectHas, SymbolFor } from \"./primordials.mjs\";\n\nexport const brand = SymbolFor(\"__Float16Array__\");\n\n/**\n * @param {unknown} target\n * @throws {TypeError}\n * @returns {boolean}\n */\nexport function hasFloat16ArrayBrand(target) {\n  if (!isObjectLike(target)) {\n    return false;\n  }\n\n  const prototype = ReflectGetPrototypeOf(target);\n  if (!isObjectLike(prototype)) {\n    return false;\n  }\n\n  const constructor = prototype.constructor;\n  if (constructor === undefined) {\n    return false;\n  }\n  if (!isObject(constructor)) {\n    throw NativeTypeError(THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);\n  }\n\n  return ReflectHas(constructor, brand);\n}\n", "import {\n  EPSILON,\n  MathAbs,\n  NativeArrayBuffer,\n  NativeFloat32Array,\n  NativeUint16Array,\n  NativeUint32Array,\n  NativeUint8Array,\n  NumberIsFinite,\n  NumberIsNaN,\n} from \"./primordials.mjs\";\n\nconst INVERSE_OF_EPSILON = 1 / EPSILON;\n\n/**\n * rounds to the nearest value;\n * if the number falls midway, it is rounded to the nearest value with an even least significant digit\n * @param {number} num\n * @returns {number}\n */\nfunction roundTiesToEven(num) {\n  return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n}\n\nconst FLOAT16_MIN_VALUE = 6.103515625e-05;\nconst FLOAT16_MAX_VALUE = 65504;\nconst FLOAT16_EPSILON = 0.0009765625;\n\nconst FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\nconst FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n/**\n * round a number to a half float number\n * @param {unknown} num - double float\n * @returns {number} half float number\n */\nexport function roundToFloat16(num) {\n  const number = +num;\n\n  // NaN, Infinity, -Infinity, 0, -0\n  if (!NumberIsFinite(number) || number === 0) {\n    return number;\n  }\n\n  // finite except 0, -0\n  const sign = number > 0 ? 1 : -1;\n  const absolute = MathAbs(number);\n\n  // small number\n  if (absolute < FLOAT16_MIN_VALUE) {\n    return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n  }\n\n  const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n  const result = temp - (temp - absolute);\n\n  // large number\n  if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {\n    return sign * Infinity;\n  }\n\n  return sign * result;\n}\n\n// base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst buffer = new NativeArrayBuffer(4);\nconst floatView = new NativeFloat32Array(buffer);\nconst uint32View = new NativeUint32Array(buffer);\n\nconst baseTable = new NativeUint16Array(512);\nconst shiftTable = new NativeUint8Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -24) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16Bits(num) {\n  floatView[0] = roundToFloat16(num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new NativeUint32Array(2048);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nconst exponentTable = new NativeUint32Array(64);\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nconst offsetTable = new NativeUint16Array(64);\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nexport function convertToNumber(float16bits) {\n  const i = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n  return floatView[0];\n}\n", "import { isObject, isSharedArrayBuffer } from \"./is.mjs\";\nimport {\n  THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT,\n  THIS_IS_NOT_AN_OBJECT,\n} from \"./messages.mjs\";\nimport {\n  ArrayBufferPrototypeSlice,\n  MAX_SAFE_INTEGER,\n  MathTrunc,\n  NativeTypeError,\n  NumberIsNaN,\n  ObjectIs,\n  SymbolSpecies,\n} from \"./primordials.mjs\";\n\n/**\n * @see https://tc39.es/ecma262/#sec-tointegerorinfinity\n * @param {unknown} target\n * @returns {number}\n */\nexport function ToIntegerOrInfinity(target) {\n  const number = +target;\n\n  if (NumberIsNaN(number) || number === 0) {\n    return 0;\n  }\n\n  return MathTrunc(number);\n}\n\n/**\n * @see https://tc39.es/ecma262/#sec-tolength\n * @param {unknown} target\n * @returns {number}\n */\nexport function ToLength(target) {\n  const length = ToIntegerOrInfinity(target);\n  if (length < 0) {\n    return 0;\n  }\n\n  return length < MAX_SAFE_INTEGER\n    ? length\n    : MAX_SAFE_INTEGER;\n}\n\n/**\n * @see https://tc39.es/ecma262/#sec-speciesconstructor\n * @param {object} target\n * @param {{ new(...args: any[]): any; }} defaultConstructor\n * @returns {{ new(...args: any[]): any; }}\n */\nexport function SpeciesConstructor(target, defaultConstructor) {\n  if (!isObject(target)) {\n    throw NativeTypeError(THIS_IS_NOT_AN_OBJECT);\n  }\n\n  const constructor = target.constructor;\n  if (constructor === undefined) {\n    return defaultConstructor;\n  }\n  if (!isObject(constructor)) {\n    throw NativeTypeError(THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);\n  }\n\n  const species = constructor[SymbolSpecies];\n  if (species == null) {\n    return defaultConstructor;\n  }\n\n  return species;\n}\n\n/**\n * @see https://tc39.es/ecma262/#sec-isdetachedbuffer\n * @param {ArrayBufferLike} buffer\n * @returns {boolean}\n */\nexport function IsDetachedBuffer(buffer) {\n  if (isSharedArrayBuffer(buffer)) {\n    return false;\n  }\n\n  try {\n    ArrayBufferPrototypeSlice(buffer, 0, 0);\n    return false;\n  } catch (e) {/* empty */}\n\n  return true;\n}\n\n/**\n * bigint comparisons are not supported\n * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort\n * @param {number} x\n * @param {number} y\n * @returns {-1 | 0 | 1}\n */\nexport function defaultCompare(x, y) {\n  const isXNaN = NumberIsNaN(x);\n  const isYNaN = NumberIsNaN(y);\n\n  if (isXNaN && isYNaN) {\n    return 0;\n  }\n\n  if (isXNaN) {\n    return 1;\n  }\n\n  if (isYNaN) {\n    return -1;\n  }\n\n  if (x < y) {\n    return -1;\n  }\n\n  if (x > y) {\n    return 1;\n  }\n\n  if (x === 0 && y === 0) {\n    const isXPlusZero = ObjectIs(x, 0);\n    const isYPlusZero = ObjectIs(y, 0);\n\n    if (!isXPlusZero && isYPlusZero) {\n      return -1;\n    }\n\n    if (isXPlusZero && !isYPlusZero) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n", "import { safeIfNeeded, wrap } from \"./_util/arrayIterator.mjs\";\nimport { brand, hasFloat16ArrayBrand } from \"./_util/brand.mjs\";\nimport { convertToNumber, roundToFloat16Bits } from \"./_util/converter.mjs\";\nimport {\n  isAnyArrayBuffer,\n  isCanonicalIntegerIndexString,\n  isNativeBigIntTypedArray,\n  isNativeTypedArray,\n  isObject,\n  isOrdinaryArray,\n  isOrdinaryNativeTypedArray,\n} from \"./_util/is.mjs\";\nimport {\n  ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER,\n  CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT,\n  CANNOT_MIX_BIGINT_AND_OTHER_TYPES,\n  DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH,\n  ITERATOR_PROPERTY_IS_NOT_CALLABLE,\n  OFFSET_IS_OUT_OF_BOUNDS,\n  REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE,\n  SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT,\n  THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED,\n  THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY,\n  THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT,\n} from \"./_util/messages.mjs\";\nimport {\n  ArrayBufferIsView,\n  ArrayPrototypeJoin,\n  ArrayPrototypePush,\n  ArrayPrototypeToLocaleString,\n  NativeArrayBuffer,\n  NativeObject,\n  NativeProxy,\n  NativeRangeError,\n  NativeTypeError,\n  NativeUint16Array,\n  NativeWeakMap,\n  NativeWeakSet,\n  NumberIsNaN,\n  ObjectDefineProperty,\n  ObjectFreeze,\n  ObjectHasOwn,\n  ObjectPrototype__lookupGetter__,\n  ReflectApply,\n  ReflectConstruct,\n  ReflectDefineProperty,\n  ReflectGet,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectHas,\n  ReflectOwnKeys,\n  ReflectSet,\n  ReflectSetPrototypeOf,\n  SymbolIterator,\n  SymbolToStringTag,\n  TypedArray,\n  TypedArrayPrototype,\n  TypedArrayPrototypeCopyWithin,\n  TypedArrayPrototypeEntries,\n  TypedArrayPrototypeFill,\n  TypedArrayPrototypeGetBuffer,\n  TypedArrayPrototypeGetByteOffset,\n  TypedArrayPrototypeGetLength,\n  TypedArrayPrototypeKeys,\n  TypedArrayPrototypeReverse,\n  TypedArrayPrototypeSet,\n  TypedArrayPrototypeSlice,\n  TypedArrayPrototypeSort,\n  TypedArrayPrototypeSubarray,\n  TypedArrayPrototypeValues,\n  Uint16ArrayFrom,\n  WeakMapPrototypeGet,\n  WeakMapPrototypeHas,\n  WeakMapPrototypeSet,\n  WeakSetPrototypeAdd,\n  WeakSetPrototypeHas,\n} from \"./_util/primordials.mjs\";\nimport {\n  IsDetachedBuffer,\n  SpeciesConstructor,\n  ToIntegerOrInfinity,\n  ToLength,\n  defaultCompare,\n} from \"./_util/spec.mjs\";\n\nconst BYTES_PER_ELEMENT = 2;\n\n/** @typedef {Uint16Array & { __float16bits: never }} Float16BitsArray */\n\n/** @type {WeakMap<Float16Array, Float16BitsArray>} */\nconst float16bitsArrays = new NativeWeakMap();\n\n/**\n * @param {unknown} target\n * @returns {target is Float16Array}\n */\nexport function isFloat16Array(target) {\n  return WeakMapPrototypeHas(float16bitsArrays, target) ||\n    (!ArrayBufferIsView(target) && hasFloat16ArrayBrand(target));\n}\n\n/**\n * @param {unknown} target\n * @throws {TypeError}\n * @returns {asserts target is Float16Array}\n */\nfunction assertFloat16Array(target) {\n  if (!isFloat16Array(target)) {\n    throw NativeTypeError(THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT);\n  }\n}\n\n/**\n * @param {unknown} target\n * @param {number=} count\n * @throws {TypeError}\n * @returns {asserts target is Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float16Array|Float32Array|Float64Array}\n */\nfunction assertSpeciesTypedArray(target, count) {\n  const isTargetFloat16Array = isFloat16Array(target);\n  const isTargetTypedArray = isNativeTypedArray(target);\n\n  if (!isTargetFloat16Array && !isTargetTypedArray) {\n    throw NativeTypeError(SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT);\n  }\n\n  if (typeof count === \"number\") {\n    let length;\n    if (isTargetFloat16Array) {\n      const float16bitsArray = getFloat16BitsArray(target);\n      length = TypedArrayPrototypeGetLength(float16bitsArray);\n    } else {\n      length = TypedArrayPrototypeGetLength(target);\n    }\n\n    if (length < count) {\n      throw NativeTypeError(\n        DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH\n      );\n    }\n  }\n\n  if (isNativeBigIntTypedArray(target)) {\n    throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n  }\n}\n\n/**\n * @param {Float16Array} float16\n * @throws {TypeError}\n * @returns {Float16BitsArray}\n */\nfunction getFloat16BitsArray(float16) {\n  const float16bitsArray = WeakMapPrototypeGet(float16bitsArrays, float16);\n  if (float16bitsArray !== undefined) {\n    const buffer = TypedArrayPrototypeGetBuffer(float16bitsArray);\n\n    if (IsDetachedBuffer(buffer)) {\n      throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n    }\n\n    return float16bitsArray;\n  }\n\n  // from another Float16Array instance (a different version?)\n  const buffer = /** @type {any} */ (float16).buffer;\n\n  if (IsDetachedBuffer(buffer)) {\n    throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n  }\n\n  const cloned = ReflectConstruct(Float16Array, [\n    buffer,\n    /** @type {any} */ (float16).byteOffset,\n    /** @type {any} */ (float16).length,\n  ], float16.constructor);\n  return WeakMapPrototypeGet(float16bitsArrays, cloned);\n}\n\n/**\n * @param {Float16BitsArray} float16bitsArray\n * @returns {number[]}\n */\nfunction copyToArray(float16bitsArray) {\n  const length = TypedArrayPrototypeGetLength(float16bitsArray);\n\n  const array = [];\n  for (let i = 0; i < length; ++i) {\n    array[i] = convertToNumber(float16bitsArray[i]);\n  }\n\n  return array;\n}\n\n/** @type {WeakSet<Function>} */\nconst TypedArrayPrototypeGetters = new NativeWeakSet();\nfor (const key of ReflectOwnKeys(TypedArrayPrototype)) {\n  // @@toStringTag getter property is defined in Float16Array.prototype\n  if (key === SymbolToStringTag) {\n    continue;\n  }\n\n  const descriptor = ReflectGetOwnPropertyDescriptor(TypedArrayPrototype, key);\n  if (ObjectHasOwn(descriptor, \"get\") && typeof descriptor.get === \"function\") {\n    WeakSetPrototypeAdd(TypedArrayPrototypeGetters, descriptor.get);\n  }\n}\n\nconst handler = ObjectFreeze(/** @type {ProxyHandler<Float16BitsArray>} */ ({\n  get(target, key, receiver) {\n    if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n      return convertToNumber(ReflectGet(target, key));\n    }\n\n    // %TypedArray%.prototype getter properties cannot called by Proxy receiver\n    if (WeakSetPrototypeHas(TypedArrayPrototypeGetters, ObjectPrototype__lookupGetter__(target, key))) {\n      return ReflectGet(target, key);\n    }\n\n    return ReflectGet(target, key, receiver);\n  },\n\n  set(target, key, value, receiver) {\n    if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n      return ReflectSet(target, key, roundToFloat16Bits(value));\n    }\n\n    return ReflectSet(target, key, value, receiver);\n  },\n\n  getOwnPropertyDescriptor(target, key) {\n    if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      descriptor.value = convertToNumber(descriptor.value);\n      return descriptor;\n    }\n\n    return ReflectGetOwnPropertyDescriptor(target, key);\n  },\n\n  defineProperty(target, key, descriptor) {\n    if (\n      isCanonicalIntegerIndexString(key) &&\n      ObjectHasOwn(target, key) &&\n      ObjectHasOwn(descriptor, \"value\")\n    ) {\n      descriptor.value = roundToFloat16Bits(descriptor.value);\n      return ReflectDefineProperty(target, key, descriptor);\n    }\n\n    return ReflectDefineProperty(target, key, descriptor);\n  },\n}));\n\nexport class Float16Array {\n  /** @see https://tc39.es/ecma262/#sec-typedarray */\n  constructor(input, _byteOffset, _length) {\n    /** @type {Float16BitsArray} */\n    let float16bitsArray;\n\n    if (isFloat16Array(input)) {\n      float16bitsArray = ReflectConstruct(NativeUint16Array, [getFloat16BitsArray(input)], new.target);\n    } else if (isObject(input) && !isAnyArrayBuffer(input)) { // object without ArrayBuffer, SharedArrayBuffer\n      /** @type {ArrayLike<unknown>} */\n      let list;\n      /** @type {number} */\n      let length;\n\n      if (isNativeTypedArray(input)) { // TypedArray\n        list = input;\n        length = TypedArrayPrototypeGetLength(input);\n\n        const buffer = TypedArrayPrototypeGetBuffer(input);\n\n        if (IsDetachedBuffer(buffer)) {\n          throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n        }\n\n        if (isNativeBigIntTypedArray(input)) {\n          throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n        }\n\n        const data = new NativeArrayBuffer(\n          length * BYTES_PER_ELEMENT\n        );\n        float16bitsArray = ReflectConstruct(NativeUint16Array, [data], new.target);\n      } else {\n        const iterator = input[SymbolIterator];\n        if (iterator != null && typeof iterator !== \"function\") {\n          throw NativeTypeError(ITERATOR_PROPERTY_IS_NOT_CALLABLE);\n        }\n\n        if (iterator != null) { // Iterable (Array)\n          // for optimization\n          if (isOrdinaryArray(input)) {\n            list = input;\n            length = input.length;\n          } else {\n            // eslint-disable-next-line no-restricted-syntax\n            list = [... /** @type {Iterable<unknown>} */ (input)];\n            length = list.length;\n          }\n        } else { // ArrayLike\n          list = /** @type {ArrayLike<unknown>} */ (input);\n          length = ToLength(list.length);\n        }\n        float16bitsArray = ReflectConstruct(NativeUint16Array, [length], new.target);\n      }\n\n      // set values\n      for (let i = 0; i < length; ++i) {\n        float16bitsArray[i] = roundToFloat16Bits(list[i]);\n      }\n    } else { // primitive, ArrayBuffer, SharedArrayBuffer\n      float16bitsArray = ReflectConstruct(NativeUint16Array, arguments, new.target);\n    }\n\n    /** @type {Float16Array} */\n    const proxy = /** @type {any} */ (new NativeProxy(float16bitsArray, handler));\n\n    // proxy private storage\n    WeakMapPrototypeSet(float16bitsArrays, proxy, float16bitsArray);\n\n    return proxy;\n  }\n\n  /**\n   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key\n   * @see https://tc39.es/ecma262/#sec-%typedarray%.from\n   */\n  static from(src, ...opts) {\n    const Constructor = this;\n\n    if (!ReflectHas(Constructor, brand)) {\n      throw NativeTypeError(\n        THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY\n      );\n    }\n\n    // for optimization\n    if (Constructor === Float16Array) {\n      if (isFloat16Array(src) && opts.length === 0) {\n        const float16bitsArray = getFloat16BitsArray(src);\n        const uint16 = new NativeUint16Array(\n          TypedArrayPrototypeGetBuffer(float16bitsArray),\n          TypedArrayPrototypeGetByteOffset(float16bitsArray),\n          TypedArrayPrototypeGetLength(float16bitsArray)\n        );\n        return new Float16Array(\n          TypedArrayPrototypeGetBuffer(TypedArrayPrototypeSlice(uint16))\n        );\n      }\n\n      if (opts.length === 0) {\n        return new Float16Array(\n          TypedArrayPrototypeGetBuffer(\n            Uint16ArrayFrom(src, roundToFloat16Bits)\n          )\n        );\n      }\n\n      const mapFunc = opts[0];\n      const thisArg = opts[1];\n\n      return new Float16Array(\n        TypedArrayPrototypeGetBuffer(\n          Uint16ArrayFrom(src, function (val, ...args) {\n            return roundToFloat16Bits(\n              ReflectApply(mapFunc, this, [val, ...safeIfNeeded(args)])\n            );\n          }, thisArg)\n        )\n      );\n    }\n\n    /** @type {ArrayLike<unknown>} */\n    let list;\n    /** @type {number} */\n    let length;\n\n    const iterator = src[SymbolIterator];\n    if (iterator != null && typeof iterator !== \"function\") {\n      throw NativeTypeError(ITERATOR_PROPERTY_IS_NOT_CALLABLE);\n    }\n\n    if (iterator != null) { // Iterable (TypedArray, Array)\n      // for optimization\n      if (isOrdinaryArray(src)) {\n        list = src;\n        length = src.length;\n      } else if (isOrdinaryNativeTypedArray(src)) {\n        list = src;\n        length = TypedArrayPrototypeGetLength(src);\n      } else {\n        // eslint-disable-next-line no-restricted-syntax\n        list = [...src];\n        length = list.length;\n      }\n    } else { // ArrayLike\n      if (src == null) {\n        throw NativeTypeError(\n          CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n        );\n      }\n      list = NativeObject(src);\n      length = ToLength(list.length);\n    }\n\n    const array = new Constructor(length);\n\n    if (opts.length === 0) {\n      for (let i = 0; i < length; ++i) {\n        array[i] = /** @type {number} */ (list[i]);\n      }\n    } else {\n      const mapFunc = opts[0];\n      const thisArg = opts[1];\n      for (let i = 0; i < length; ++i) {\n        array[i] = ReflectApply(mapFunc, thisArg, [list[i], i]);\n      }\n    }\n\n    return array;\n  }\n\n  /**\n   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key\n   * @see https://tc39.es/ecma262/#sec-%typedarray%.of\n   */\n  static of(...items) {\n    const Constructor = this;\n\n    if (!ReflectHas(Constructor, brand)) {\n      throw NativeTypeError(\n        THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY\n      );\n    }\n\n    const length = items.length;\n\n    // for optimization\n    if (Constructor === Float16Array) {\n      const proxy = new Float16Array(length);\n      const float16bitsArray = getFloat16BitsArray(proxy);\n\n      for (let i = 0; i < length; ++i) {\n        float16bitsArray[i] = roundToFloat16Bits(items[i]);\n      }\n\n      return proxy;\n    }\n\n    const array = new Constructor(length);\n\n    for (let i = 0; i < length; ++i) {\n      array[i] = items[i];\n    }\n\n    return array;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys */\n  keys() {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    return TypedArrayPrototypeKeys(float16bitsArray);\n  }\n\n  /**\n   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`\n   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.values\n   */\n  values() {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    return wrap((function* () {\n      // eslint-disable-next-line no-restricted-syntax\n      for (const val of TypedArrayPrototypeValues(float16bitsArray)) {\n        yield convertToNumber(val);\n      }\n    })());\n  }\n\n  /**\n   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`\n   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries\n   */\n  entries() {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    return wrap((function* () {\n      // eslint-disable-next-line no-restricted-syntax\n      for (const [i, val] of TypedArrayPrototypeEntries(float16bitsArray)) {\n        yield /** @type {[number, number]} */ ([i, convertToNumber(val)]);\n      }\n    })());\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.at */\n  at(index) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const relativeIndex = ToIntegerOrInfinity(index);\n    const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n\n    if (k < 0 || k >= length) {\n      return;\n    }\n\n    return convertToNumber(float16bitsArray[k]);\n  }\n\n  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with */\n  with(index, value) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const relativeIndex = ToIntegerOrInfinity(index);\n    const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n\n    const number = +value;\n\n    if (k < 0 || k >= length) {\n      throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n    }\n\n    // don't use SpeciesConstructor\n    const uint16 = new NativeUint16Array(\n      TypedArrayPrototypeGetBuffer(float16bitsArray),\n      TypedArrayPrototypeGetByteOffset(float16bitsArray),\n      TypedArrayPrototypeGetLength(float16bitsArray)\n    );\n    const cloned = new Float16Array(\n      TypedArrayPrototypeGetBuffer(\n        TypedArrayPrototypeSlice(uint16)\n      )\n    );\n    const array = getFloat16BitsArray(cloned);\n\n    array[k] = roundToFloat16Bits(number);\n\n    return cloned;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.map */\n  map(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const thisArg = opts[0];\n\n    const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n\n    // for optimization\n    if (Constructor === Float16Array) {\n      const proxy = new Float16Array(length);\n      const array = getFloat16BitsArray(proxy);\n\n      for (let i = 0; i < length; ++i) {\n        const val = convertToNumber(float16bitsArray[i]);\n        array[i] = roundToFloat16Bits(\n          ReflectApply(callback, thisArg, [val, i, this])\n        );\n      }\n\n      return proxy;\n    }\n\n    const array = new Constructor(length);\n    assertSpeciesTypedArray(array, length);\n\n    for (let i = 0; i < length; ++i) {\n      const val = convertToNumber(float16bitsArray[i]);\n      array[i] = ReflectApply(callback, thisArg, [val, i, this]);\n    }\n\n    return /** @type {any} */ (array);\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter */\n  filter(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const thisArg = opts[0];\n\n    const kept = [];\n    for (let i = 0; i < length; ++i) {\n      const val = convertToNumber(float16bitsArray[i]);\n      if (ReflectApply(callback, thisArg, [val, i, this])) {\n        ArrayPrototypePush(kept, val);\n      }\n    }\n\n    const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n    const array = new Constructor(kept);\n    assertSpeciesTypedArray(array);\n\n    return /** @type {any} */ (array);\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce */\n  reduce(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    if (length === 0 && opts.length === 0) {\n      throw NativeTypeError(REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);\n    }\n\n    let accumulator, start;\n    if (opts.length === 0) {\n      accumulator = convertToNumber(float16bitsArray[0]);\n      start = 1;\n    } else {\n      accumulator = opts[0];\n      start = 0;\n    }\n\n    for (let i = start; i < length; ++i) {\n      accumulator = callback(\n        accumulator,\n        convertToNumber(float16bitsArray[i]),\n        i,\n        this\n      );\n    }\n\n    return accumulator;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright */\n  reduceRight(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    if (length === 0 && opts.length === 0) {\n      throw NativeTypeError(REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);\n    }\n\n    let accumulator, start;\n    if (opts.length === 0) {\n      accumulator = convertToNumber(float16bitsArray[length - 1]);\n      start = length - 2;\n    } else {\n      accumulator = opts[0];\n      start = length - 1;\n    }\n\n    for (let i = start; i >= 0; --i) {\n      accumulator = callback(\n        accumulator,\n        convertToNumber(float16bitsArray[i]),\n        i,\n        this\n      );\n    }\n\n    return accumulator;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach */\n  forEach(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = 0; i < length; ++i) {\n      ReflectApply(callback, thisArg, [\n        convertToNumber(float16bitsArray[i]),\n        i,\n        this,\n      ]);\n    }\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.find */\n  find(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = 0; i < length; ++i) {\n      const value = convertToNumber(float16bitsArray[i]);\n      if (ReflectApply(callback, thisArg, [value, i, this])) {\n        return value;\n      }\n    }\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex */\n  findIndex(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = 0; i < length; ++i) {\n      const value = convertToNumber(float16bitsArray[i]);\n      if (ReflectApply(callback, thisArg, [value, i, this])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlast */\n  findLast(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = length - 1; i >= 0; --i) {\n      const value = convertToNumber(float16bitsArray[i]);\n      if (ReflectApply(callback, thisArg, [value, i, this])) {\n        return value;\n      }\n    }\n  }\n\n  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlastindex */\n  findLastIndex(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = length - 1; i >= 0; --i) {\n      const value = convertToNumber(float16bitsArray[i]);\n      if (ReflectApply(callback, thisArg, [value, i, this])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.every */\n  every(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = 0; i < length; ++i) {\n      if (\n        !ReflectApply(callback, thisArg, [\n          convertToNumber(float16bitsArray[i]),\n          i,\n          this,\n        ])\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.some */\n  some(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = 0; i < length; ++i) {\n      if (\n        ReflectApply(callback, thisArg, [\n          convertToNumber(float16bitsArray[i]),\n          i,\n          this,\n        ])\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.set */\n  set(input, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const targetOffset = ToIntegerOrInfinity(opts[0]);\n    if (targetOffset < 0) {\n      throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n    }\n\n    if (input == null) {\n      throw NativeTypeError(\n        CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    if (isNativeBigIntTypedArray(input)) {\n      throw NativeTypeError(\n        CANNOT_MIX_BIGINT_AND_OTHER_TYPES\n      );\n    }\n\n    // for optimization\n    if (isFloat16Array(input)) {\n      // peel off Proxy\n      return TypedArrayPrototypeSet(\n        getFloat16BitsArray(this),\n        getFloat16BitsArray(input),\n        targetOffset\n      );\n    }\n\n    if (isNativeTypedArray(input)) {\n      const buffer = TypedArrayPrototypeGetBuffer(input);\n      if (IsDetachedBuffer(buffer)) {\n        throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n      }\n    }\n\n    const targetLength = TypedArrayPrototypeGetLength(float16bitsArray);\n\n    const src = NativeObject(input);\n    const srcLength = ToLength(src.length);\n\n    if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {\n      throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n    }\n\n    for (let i = 0; i < srcLength; ++i) {\n      float16bitsArray[i + targetOffset] = roundToFloat16Bits(src[i]);\n    }\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse */\n  reverse() {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    TypedArrayPrototypeReverse(float16bitsArray);\n\n    return this;\n  }\n\n  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed */\n  toReversed() {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    // don't use SpeciesConstructor\n    const uint16 = new NativeUint16Array(\n      TypedArrayPrototypeGetBuffer(float16bitsArray),\n      TypedArrayPrototypeGetByteOffset(float16bitsArray),\n      TypedArrayPrototypeGetLength(float16bitsArray)\n    );\n    const cloned = new Float16Array(\n      TypedArrayPrototypeGetBuffer(\n        TypedArrayPrototypeSlice(uint16)\n      )\n    );\n\n    const clonedFloat16bitsArray = getFloat16BitsArray(cloned);\n    TypedArrayPrototypeReverse(clonedFloat16bitsArray);\n\n    return cloned;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill */\n  fill(value, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    TypedArrayPrototypeFill(\n      float16bitsArray,\n      roundToFloat16Bits(value),\n      ...safeIfNeeded(opts)\n    );\n\n    return this;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin */\n  copyWithin(target, start, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    TypedArrayPrototypeCopyWithin(float16bitsArray, target, start, ...safeIfNeeded(opts));\n\n    return this;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort */\n  sort(compareFn) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const sortCompare = compareFn !== undefined ? compareFn : defaultCompare;\n    TypedArrayPrototypeSort(float16bitsArray, (x, y) => {\n      return sortCompare(convertToNumber(x), convertToNumber(y));\n    });\n\n    return this;\n  }\n\n  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSorted */\n  toSorted(compareFn) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    if (compareFn !== undefined && typeof compareFn !== \"function\") {\n      throw new NativeTypeError(THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED);\n    }\n    const sortCompare = compareFn !== undefined ? compareFn : defaultCompare;\n\n    // don't use SpeciesConstructor\n    const uint16 = new NativeUint16Array(\n      TypedArrayPrototypeGetBuffer(float16bitsArray),\n      TypedArrayPrototypeGetByteOffset(float16bitsArray),\n      TypedArrayPrototypeGetLength(float16bitsArray)\n    );\n    const cloned = new Float16Array(\n      TypedArrayPrototypeGetBuffer(\n        TypedArrayPrototypeSlice(uint16)\n      )\n    );\n\n    const clonedFloat16bitsArray = getFloat16BitsArray(cloned);\n    TypedArrayPrototypeSort(clonedFloat16bitsArray, (x, y) => {\n      return sortCompare(convertToNumber(x), convertToNumber(y));\n    });\n\n    return cloned;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice */\n  slice(start, end) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n\n    // for optimization\n    if (Constructor === Float16Array) {\n      const uint16 = new NativeUint16Array(\n        TypedArrayPrototypeGetBuffer(float16bitsArray),\n        TypedArrayPrototypeGetByteOffset(float16bitsArray),\n        TypedArrayPrototypeGetLength(float16bitsArray)\n      );\n      return new Float16Array(\n        TypedArrayPrototypeGetBuffer(\n          TypedArrayPrototypeSlice(uint16, start, end)\n        )\n      );\n    }\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const relativeStart = ToIntegerOrInfinity(start);\n    const relativeEnd = end === undefined ? length : ToIntegerOrInfinity(end);\n\n    let k;\n    if (relativeStart === -Infinity) {\n      k = 0;\n    } else if (relativeStart < 0) {\n      k = length + relativeStart > 0 ? length + relativeStart : 0;\n    } else {\n      k = length < relativeStart ? length : relativeStart;\n    }\n\n    let final;\n    if (relativeEnd === -Infinity) {\n      final = 0;\n    } else if (relativeEnd < 0) {\n      final = length + relativeEnd > 0 ? length + relativeEnd : 0;\n    } else {\n      final = length < relativeEnd ? length : relativeEnd;\n    }\n\n    const count = final - k > 0 ? final - k : 0;\n    const array = new Constructor(count);\n    assertSpeciesTypedArray(array, count);\n\n    if (count === 0) {\n      return array;\n    }\n\n    const buffer = TypedArrayPrototypeGetBuffer(float16bitsArray);\n    if (IsDetachedBuffer(buffer)) {\n      throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n    }\n\n    let n = 0;\n    while (k < final) {\n      array[n] = convertToNumber(float16bitsArray[k]);\n      ++k;\n      ++n;\n    }\n\n    return /** @type {any} */ (array);\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray */\n  subarray(begin, end) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n\n    const uint16 = new NativeUint16Array(\n      TypedArrayPrototypeGetBuffer(float16bitsArray),\n      TypedArrayPrototypeGetByteOffset(float16bitsArray),\n      TypedArrayPrototypeGetLength(float16bitsArray)\n    );\n    const uint16Subarray = TypedArrayPrototypeSubarray(uint16, begin, end);\n\n    const array = new Constructor(\n      TypedArrayPrototypeGetBuffer(uint16Subarray),\n      TypedArrayPrototypeGetByteOffset(uint16Subarray),\n      TypedArrayPrototypeGetLength(uint16Subarray)\n    );\n    assertSpeciesTypedArray(array);\n\n    return /** @type {any} */ (array);\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof */\n  indexOf(element, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n\n    let from = ToIntegerOrInfinity(opts[0]);\n    if (from === Infinity) {\n      return -1;\n    }\n\n    if (from < 0) {\n      from += length;\n      if (from < 0) {\n        from = 0;\n      }\n    }\n\n    for (let i = from; i < length; ++i) {\n      if (\n        ObjectHasOwn(float16bitsArray, i) &&\n        convertToNumber(float16bitsArray[i]) === element\n      ) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof */\n  lastIndexOf(element, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n\n    let from = opts.length >= 1 ? ToIntegerOrInfinity(opts[0]) : length - 1;\n    if (from === -Infinity) {\n      return -1;\n    }\n\n    if (from >= 0) {\n      from = from < length - 1 ? from : length - 1;\n    } else {\n      from += length;\n    }\n\n    for (let i = from; i >= 0; --i) {\n      if (\n        ObjectHasOwn(float16bitsArray, i) &&\n        convertToNumber(float16bitsArray[i]) === element\n      ) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes */\n  includes(element, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n\n    let from = ToIntegerOrInfinity(opts[0]);\n    if (from === Infinity) {\n      return false;\n    }\n\n    if (from < 0) {\n      from += length;\n      if (from < 0) {\n        from = 0;\n      }\n    }\n\n    const isNaN = NumberIsNaN(element);\n    for (let i = from; i < length; ++i) {\n      const value = convertToNumber(float16bitsArray[i]);\n\n      if (isNaN && NumberIsNaN(value)) {\n        return true;\n      }\n\n      if (value === element) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.join */\n  join(separator) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const array = copyToArray(float16bitsArray);\n\n    return ArrayPrototypeJoin(array, separator);\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring */\n  toLocaleString(...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n\n    const array = copyToArray(float16bitsArray);\n\n    return ArrayPrototypeToLocaleString(array, ...safeIfNeeded(opts));\n  }\n\n  /** @see https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag */\n  get [SymbolToStringTag]() {\n    if (isFloat16Array(this)) {\n      return /** @type {any} */ (\"Float16Array\");\n    }\n  }\n}\n\n/** @see https://tc39.es/ecma262/#sec-typedarray.bytes_per_element */\nObjectDefineProperty(Float16Array, \"BYTES_PER_ELEMENT\", {\n  value: BYTES_PER_ELEMENT,\n});\n\n// limitation: It is peaked by `Object.getOwnPropertySymbols(Float16Array)` and `Reflect.ownKeys(Float16Array)`\nObjectDefineProperty(Float16Array, brand, {});\n\n/** @see https://tc39.es/ecma262/#sec-properties-of-the-typedarray-constructors */\nReflectSetPrototypeOf(Float16Array, TypedArray);\n\nconst Float16ArrayPrototype = Float16Array.prototype;\n\n/** @see https://tc39.es/ecma262/#sec-typedarray.prototype.bytes_per_element */\nObjectDefineProperty(Float16ArrayPrototype, \"BYTES_PER_ELEMENT\", {\n  value: BYTES_PER_ELEMENT,\n});\n\n/** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator */\nObjectDefineProperty(Float16ArrayPrototype, SymbolIterator, {\n  value: Float16ArrayPrototype.values,\n  writable: true,\n  configurable: true,\n});\n\nReflectSetPrototypeOf(Float16ArrayPrototype, TypedArrayPrototype);\n", "import { safeIfNeeded } from \"./_util/arrayIterator.mjs\";\nimport { convertToNumber, roundToFloat16Bits } from \"./_util/converter.mjs\";\nimport {\n  DataViewPrototypeGetUint16,\n  DataViewPrototypeSetUint16,\n} from \"./_util/primordials.mjs\";\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nexport function getFloat16(dataView, byteOffset, ...opts) {\n  return convertToNumber(\n    DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nexport function setFloat16(dataView, byteOffset, value, ...opts) {\n  return DataViewPrototypeSetUint16(\n    dataView,\n    byteOffset,\n    roundToFloat16Bits(value),\n    ...safeIfNeeded(opts)\n  );\n}\n", "/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n", "export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n", "const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n", "/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n", "import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n", "export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n", "import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n", "const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n", "/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n", "export default class QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n", "export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n", "import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n", "export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n", "import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n", "import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n", "import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n", "import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n", "import { BaseSource } from './basesource.js';\nimport { AbortError } from '../utils.js';\n\nclass ArrayBufferSource extends BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nexport function makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n", "import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n", "import fs from 'fs';\nimport { BaseSource } from './basesource.js';\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nexport function makeFileSource(path) {\n  return new FileSource(path);\n}\n", "/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey of geoKeys) {\n    if (metadata.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n    'RowsPerStrip',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n", "/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nexport function setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nexport function debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nexport function log(...args) {\n  return LOGGER.log(...args);\n}\n\nexport function info(...args) {\n  return LOGGER.info(...args);\n}\n\nexport function warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nexport function error(...args) {\n  return LOGGER.error(...args);\n}\n\nexport function time(...args) {\n  return LOGGER.time(...args);\n}\n\nexport function timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n", "/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n"],
  "mappings": "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",
  "names": ["getAttribute", "startIndex", "findTagsByName", "next", "buffer", "buffer", "array", "buffer", "findTagsByName", "getAttribute", "buffer", "urlMod", "http", "https", "fs", "buffer", "values", "values", "values"]
}
